import { AdhocMetric } from './Metric';
import { TimeRange } from './Time';
import { AdhocFilter } from './Filter';
import { BinaryOperator, SetOperator } from './Operator';
import { AnnotationLayer } from './AnnotationLayer';
import { QueryObject } from './Query';
export declare type QueryFormDataMetric = string | AdhocMetric;
export declare type QueryFormResidualDataValue = string | AdhocMetric;
export declare type QueryFormResidualData = {
    [key: string]: any;
};
export declare type TimeRangeEndpoint = 'unknown' | 'inclusive' | 'exclusive';
export declare type TimeRangeEndpoints = [TimeRangeEndpoint, TimeRangeEndpoint];
export declare type QueryFields = {
    [key: string]: string;
};
export declare type QueryFormExtraFilter = {
    col: string;
} & ({
    op: BinaryOperator;
    val: string;
} | {
    op: SetOperator;
    val: string[];
});
export declare type ExtraFormData = {
    append_form_data?: Partial<QueryObject>;
    override_form_data?: Partial<QueryObject>;
};
export declare type BaseFormData = {
    /** datasource identifier ${id}_${type} */
    datasource: string;
    /**
     * visualization type
     * - necessary if you use the plugin and want to use
     * buildQuery function from the plugin.
     * This must match the key used when registering the plugin.
     * - not necessary if you do not plan to use the
     * buildQuery function from the plugin.
     * Can put "custom" (or any string) in this field in that case.
     */
    viz_type: string;
    /** list of columns to group by */
    groupby?: string[];
    where?: string;
    columns?: string[];
    all_columns?: string[];
    /** list of filters */
    adhoc_filters?: AdhocFilter[];
    extra_filters?: QueryFormExtraFilter[];
    /** order descending */
    order_desc?: boolean;
    /** limit number of time series */
    limit?: number;
    /** limit number of row in the results */
    row_limit?: string | number | null;
    /** row offset for server side pagination */
    row_offset?: string | number | null;
    /** The metric used to order timeseries for limiting */
    timeseries_limit_metric?: QueryFormResidualDataValue;
    /** Force refresh */
    force?: boolean;
    result_format?: string;
    result_type?: string;
    queryFields?: QueryFields;
    time_range_endpoints?: TimeRangeEndpoints;
    annotation_layers?: AnnotationLayer[];
    url_params?: Record<string, string>;
} & TimeRange & ExtraFormData & QueryFormResidualData;
export declare type SqlaFormData = {
    granularity_sqla: string;
    time_grain_sqla?: string;
    having?: string;
} & BaseFormData;
export declare type DruidFormData = {
    granularity: string;
    having_druid?: string;
    druid_time_origin?: string;
} & BaseFormData;
export declare type QueryFormData = SqlaFormData | DruidFormData;
export declare function isDruidFormData(formData: QueryFormData): formData is DruidFormData;
//# sourceMappingURL=QueryFormData.d.ts.map